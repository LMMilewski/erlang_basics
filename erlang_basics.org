# -*- org -*-

* Table of contents
** Intro
*** we will discuss:
**** basic sequential Erlang features
**** most useful basic modules
**** basic tools used to develop with Erlang
**** basics of gen_event behaviour
**** documentation navigation
*** we won't discuss:
**** distributed stuff
**** OTP libraries (apart from gen_event)
**** databases
**** monitoring, operation and maintenance modules
**** most of stdlib modules
**** most interface modules
**** more advanced tools (i.e. profilers)
*** The goal
   We want to build server that is
**** Fault tolerant
     + If user process crashes, no other user can be affected
     + If a feature process crashes user can see only that feature
       crash (In particular the user should be able to play)
     + If the machine crashes all users should be able to play on
       another machine
**** Live upgradable
     + We should be able to upgrade the game without shutting it down
**** Measurable
     + For every feature we want to know exactly how the user is using
       it (so we can improve his experience)
*** Web
**** http://www.erlang.org/doc/
**** http://demo.erlang.org/erldoc
**** http://www.erlang.se/doc/programming_rules.shtml
**** http://learnyousomeerlang.com/contents
**** http://www.tryerlang.org/
**** http://www.erlang.org/doc/getting_started/users_guide.html
*** Books
   - Making reliable distributed system in the presence of software errors
   - Erlang Programming
   - Programming Erlang
   - Erlang and OTP in Action
   - Concurrent programming in erlang
*** Navigating in Erlang documentation
   - http://www.erlang.org/doc/
   - Applications
   - example: Mnesia "Reference Manual" vs "User's Guide"
** Sequential Erlang *sequential.erl*
   - data types
   - pattern matching
   - functions, funs, guards, BIFs, lists:map
   - recursion, tail recursion
   - conditionals
   - macros
   - list:map, lists:foreach, lists:foldl, lists:foldr
*** don't use
   - catch (use try...catch if you have to)
   - process dictionary (put, get)
   - process_info
** Basic libraries
*** kernel
   - sasl (*logging.erl*)
   - code (*mycode.erl*, *remotecodeload.erl*)
   - auth (*myauth.erl*)
   - rpc (*myrpc.erl*)
*** stdlib
   - lists (*http://www.erlang.org/doc/man/lists.html*)
   - dict (*http://www.erlang.org/doc/man/dict.html*)
   - sets (*http://www.erlang.org/doc/man/sets.html*)
   - random (*http://www.erlang.org/doc/man/random.html*)
   - proplists (*http://www.erlang.org/doc/man/proplists.html*)
   - string (reprezentacja, *http://www.erlang.org/doc/man/string.html*)
   - others
     + array, base64, binary (for binary data), calendar, filelib,
       filename, io, math, queue, re (regexp is obsolete!), qlc, sofs, ...
*** interface
    crypto, inets, ftp, tfpt, http, jinterface, xmerl (xml), ssh, ssl, wxErlang, ...
** core dumps
   - reason
     + running two nodes with the same name
     + incorrect MFA in erl -s command
     + not enough memory
     + limit of file descriptors number
     + SIGUSR1 (core dump + crash dump)
** The shell and tools
   - shell (*erl.erl*, *shell_cmds.erl*)
   - dialyzer
      + erlc +debug_info
      + dialyzer --build_plt --apps erts kernel stdlib mnesia eunit
      + dialyzer -Wrace_conditions -Wbehaviours -r dialyzertest/
      + --build_plt, --add_to_plt, --remove_from_plt
      + --dump_call_graph
      + --wx % older version is --gui
      + -pa dir % use when you use -include_lib
   - table visualizer
      + mnesia tables
      + ets tables (public,private,protected)
      + tv:start()
      + CRUD
   - process manager
      + pman:start()
   - application monitor
      + appmon:start()
   - etop
      + etop:start()
   - toolbar
      + toolbar:start()
   - basic profiling
      + timer:tc(M,F,A).
   - rebar
      + git clone git://github.com/basho/rebar.git
      + cd rebar
      + ./bootstrap
      + mkdir -p ~/bin && cp rebar ~/bin
      + add ~/bin to path in ~/.profile or ~/.bashrc
      + rebar -c (list available commands)
      + rebar create-app appid=sample
      + make
         - rebar get-deps
         - rebar compile
      + http://alancastro.org/2010/05/01/erlang-application-management-with-rebar.html
** Tests, types, documentation
   - documenting (*doc.erl*)
      + edoc
      + typer
   - testing
      + eunit (*fib_tests.erl*)
      + http://erlcode.wordpress.com/2010/08/30/erlang-eunit-introduction/
      + quickcheck
** The rules
   - use STDLIB if you can (i.e. lists module)
   - isolate "tricky" or "dirty" code into separate modules
   - don't make assumptions about what the caller will do with the
     results of the function (i.e. bad args!)
   - don't use clipboard inheritance
   - don't optimize code
   - try to eliminate side effects
   - make code as deterministic as possible
   - don't program defensively (example with case)
   - separate error handling and normal case code
   - tag messages and returned values
   - write tail recursive functions if possible
   - 15-20 LOC functions
   - < 400 LOC modules
   - < 80 characters lines
   - ThisIsVariableName, this_is_function_or_atom_name
   - {12, 23, 45} (not {12,23,45} or { 12, 23, 45 })
   - Don't put your name in the code
   - Document all the errors (and warnings)
   - Don't comment out old code - remove it
   - Don't introduce trailing whitespaces!
   - Commit logical changes and whitespace changes separately
   - more at http://www.erlang.se/doc/programming_rules.shtml
** Event handlers (own_event_handler.erl)
** Troubleshooting
   - problem solving
      + erlang:display(Term)
      + BIFs:
	- processes
	- erlang:ports
	- registerd
	- statistics
	- process_info
        - port_info
        - erlang:info
        - erlang:db_all_tables
	- erlang:db_info
      + debugger
      + dbg
      + seq_trace
      + sys
